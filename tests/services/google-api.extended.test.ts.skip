/**
 * Extended tests for Google API Client
 * 
 * These tests expand coverage for initialization, error handling,
 * token management, and API execution scenarios.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";

// Mock googleapis
vi.mock("googleapis", () => {
  // Declare mocks inside the factory to avoid hoisting issues
  const mockSetCredentials = vi.fn();
  const mockOn = vi.fn();
  const mockOff = vi.fn();
  const mockGenerateAuthUrl = vi.fn().mockReturnValue("https://accounts.google.com/oauth");
  const mockGetToken = vi.fn().mockResolvedValue({ tokens: { access_token: "test-token" } });
  const mockRefreshAccessToken = vi.fn().mockResolvedValue({ credentials: { access_token: "refreshed-token" } });

  // Create mock OAuth2 class
  class MockOAuth2 {
    credentials = {};
    setCredentials = mockSetCredentials;
    on = mockOn;
    off = mockOff;
    generateAuthUrl = mockGenerateAuthUrl;
    getToken = mockGetToken;
    refreshAccessToken = mockRefreshAccessToken;
  }

  // Create mock GoogleAuth class
  class MockGoogleAuth {
    getClient = vi.fn().mockResolvedValue(new MockOAuth2());
  }

  return {
    google: {
      auth: {
        OAuth2: MockOAuth2,
        GoogleAuth: MockGoogleAuth,
        fromJSON: vi.fn().mockReturnValue(new MockOAuth2()),
      },
      sheets: vi.fn().mockReturnValue({
        spreadsheets: {
          get: vi.fn().mockResolvedValue({ data: { spreadsheetId: "test-id" } }),
          values: {
            get: vi.fn().mockResolvedValue({ data: { values: [["A", "B"]] } }),
            update: vi.fn().mockResolvedValue({ data: { updatedCells: 2 } }),
            batchGet: vi.fn().mockResolvedValue({ data: { valueRanges: [] } }),
            batchUpdate: vi.fn().mockResolvedValue({ data: {} }),
          },
          batchUpdate: vi.fn().mockResolvedValue({ data: { replies: [] } }),
        },
      }),
      drive: vi.fn().mockReturnValue({
        files: {
          list: vi.fn().mockResolvedValue({ data: { files: [] } }),
          get: vi.fn().mockResolvedValue({ data: { id: "file-id" } }),
          copy: vi.fn().mockResolvedValue({ data: { id: "new-file-id" } }),
          create: vi.fn().mockResolvedValue({ data: { id: "created-id" } }),
        },
        permissions: {
          list: vi.fn().mockResolvedValue({ data: { permissions: [] } }),
          create: vi.fn().mockResolvedValue({ data: { id: "perm-id" } }),
        },
      }),
    },
  };
});

// Mock token store
const mockLoad = vi.fn();
const mockSave = vi.fn();
const mockClear = vi.fn();

vi.mock("../../src/services/token-store.js", () => ({
  EncryptedFileTokenStore: vi.fn().mockImplementation(() => ({
    load: mockLoad,
    save: mockSave,
    clear: mockClear,
  })),
}));

// Mock token manager
const mockTokenManagerStart = vi.fn();
const mockTokenManagerStop = vi.fn();
const mockForceRefresh = vi.fn();

vi.mock("../../src/services/token-manager.js", () => ({
  TokenManager: vi.fn().mockImplementation(() => ({
    start: mockTokenManagerStart,
    stop: mockTokenManagerStop,
    forceRefresh: mockForceRefresh,
  })),
}));

// Mock circuit breaker
const mockCircuitExecute = vi.fn().mockImplementation((fn) => fn());
const mockCircuitGetStats = vi.fn().mockReturnValue({ state: "closed", failures: 0 });

vi.mock("../../src/utils/circuit-breaker.js", () => {
  class MockCircuitBreaker {
    execute = mockCircuitExecute;
    getStats = mockCircuitGetStats;
  }
  return {
    CircuitBreaker: MockCircuitBreaker,
  };
});

// Mock config
vi.mock("../../src/config/env.js", () => ({
  getCircuitBreakerConfig: vi.fn().mockReturnValue({
    failureThreshold: 5,
    resetTimeout: 30000,
  }),
}));

// Mock HTTP/2 detector
vi.mock("../../src/utils/http2-detector.js", () => ({
  logHTTP2Capabilities: vi.fn(),
  validateHTTP2Config: vi.fn().mockReturnValue({ warnings: [], http2Enabled: true }),
}));

// Mock logger
vi.mock("../../src/utils/logger.js", () => ({
  logger: {
    info: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  },
}));

// Mock request context
vi.mock("../../src/utils/request-context.js", () => ({
  getRequestContext: vi.fn().mockReturnValue({ requestId: "test-req-id" }),
}));

// Mock retry utility
vi.mock("../../src/utils/retry.js", () => ({
  executeWithRetry: vi.fn().mockImplementation((fn) => fn()),
}));

import {
  GoogleApiClient,
  DEFAULT_SCOPES,
  ELEVATED_SCOPES,
  READONLY_SCOPES,
} from "../../src/services/google-api.js";

describe("GoogleApiClient Extended Tests", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockLoad.mockResolvedValue(null);
    mockSave.mockResolvedValue(undefined);
    mockClear.mockResolvedValue(undefined);
  });

  describe("initialization with stored tokens", () => {
    it("should load and use stored tokens when available", async () => {
      mockLoad.mockResolvedValue({
        access_token: "stored-access-token",
        refresh_token: "stored-refresh-token",
        expiry_date: Date.now() + 3600000,
      });

      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
        tokenStorePath: "/tmp/tokens.encrypted",
        tokenStoreKey: "0".repeat(64),
      });

      await client.initialize();

      expect(mockLoad).toHaveBeenCalled();
      expect(mockSetCredentials).toHaveBeenCalled();
    });

    it("should handle missing stored tokens gracefully", async () => {
      mockLoad.mockResolvedValue(null);

      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
      });

      await client.initialize();
      expect(client.sheets).toBeDefined();
    });

    it("should handle token store load errors", async () => {
      mockLoad.mockRejectedValue(new Error("Failed to load tokens"));

      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
        tokenStorePath: "/tmp/tokens.encrypted",
        tokenStoreKey: "0".repeat(64),
      });

      // Should not throw - gracefully continue without stored tokens
      await client.initialize();
      expect(client.sheets).toBeDefined();
    });
  });

  describe("token refresh", () => {
    it("should save new tokens when refreshed", async () => {
      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
        tokenStorePath: "/tmp/tokens.encrypted",
        tokenStoreKey: "0".repeat(64),
      });

      await client.initialize();

      // Simulate token refresh event
      const tokenCallback = mockOn.mock.calls.find(call => call[0] === "tokens")?.[1];
      if (tokenCallback) {
        await tokenCallback({ access_token: "new-token", refresh_token: "new-refresh" });
      }

      // Token save may have been called
      // This depends on implementation details
    });
  });

  describe("generateAuthUrl", () => {
    it("should generate auth URL for OAuth flow", async () => {
      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
      });

      await client.initialize();
      const url = client.generateAuthUrl({ state: "test-state" });

      expect(mockGenerateAuthUrl).toHaveBeenCalled();
      expect(url).toContain("https://accounts.google.com");
    });

    it("should throw when not initialized", () => {
      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
      });

      expect(() => client.generateAuthUrl({})).toThrow();
    });
  });

  describe("exchangeCode", () => {
    it("should exchange authorization code for tokens", async () => {
      mockGetToken.mockResolvedValue({
        tokens: {
          access_token: "exchanged-access-token",
          refresh_token: "exchanged-refresh-token",
          expiry_date: Date.now() + 3600000,
        },
      });

      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
        tokenStorePath: "/tmp/tokens.encrypted",
        tokenStoreKey: "0".repeat(64),
      });

      await client.initialize();
      const tokens = await client.exchangeCode("test-auth-code");

      expect(mockGetToken).toHaveBeenCalledWith("test-auth-code");
      expect(tokens.access_token).toBe("exchanged-access-token");
    });
  });

  describe("destroy", () => {
    it("should cleanup resources on destroy", async () => {
      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
      });

      await client.initialize();
      await client.destroy();

      // Token listener should be removed
      expect(mockOff).toHaveBeenCalled();
    });

    it("should handle destroy when not initialized", async () => {
      const client = new GoogleApiClient();

      // Should not throw
      await client.destroy();
    });
  });

  describe("getTokenStatus", () => {
    it("should return correct token status when initialized with tokens", async () => {
      mockLoad.mockResolvedValue({
        access_token: "test-access",
        refresh_token: "test-refresh",
        expiry_date: Date.now() + 3600000,
      });

      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
        tokenStorePath: "/tmp/tokens.encrypted",
        tokenStoreKey: "0".repeat(64),
      });

      await client.initialize();
      const status = client.getTokenStatus();

      expect(status.hasAccessToken).toBe(true);
      expect(status.hasRefreshToken).toBe(true);
    });
  });

  describe("isReady", () => {
    it("should return false before initialization", () => {
      const client = new GoogleApiClient();
      expect(client.isReady).toBe(false);
    });

    it("should return true after initialization", async () => {
      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
      });

      await client.initialize();
      expect(client.isReady).toBe(true);
    });
  });

  describe("clearTokens", () => {
    it("should clear stored tokens", async () => {
      const client = new GoogleApiClient({
        credentials: {
          clientId: "test-client-id",
          clientSecret: "test-client-secret",
        },
        tokenStorePath: "/tmp/tokens.encrypted",
        tokenStoreKey: "0".repeat(64),
      });

      await client.initialize();
      await client.clearTokens();

      expect(mockClear).toHaveBeenCalled();
    });
  });
});

describe.skip("GoogleApiClient scopes", () => {
  it("should correctly identify elevated access from scopes", () => {
    const client = new GoogleApiClient({
      scopes: ["https://www.googleapis.com/auth/drive"],
    });

    expect(client.hasElevatedAccess).toBe(true);
  });

  it("should correctly identify non-elevated access", () => {
    const client = new GoogleApiClient({
      scopes: ["https://www.googleapis.com/auth/drive.file"],
    });

    expect(client.hasElevatedAccess).toBe(false);
  });

  it("should identify readonly scopes", () => {
    const client = new GoogleApiClient({
      scopes: READONLY_SCOPES,
    });

    expect(client.scopes).toEqual(READONLY_SCOPES);
    expect(client.hasElevatedAccess).toBe(false);
  });
});

describe.skip("GoogleApiClient error handling", () => {
  it("should throw when accessing sheets before initialization", () => {
    const client = new GoogleApiClient();
    expect(() => client.sheets).toThrow("Google API client not initialized");
  });

  it("should throw when accessing drive before initialization", () => {
    const client = new GoogleApiClient();
    expect(() => client.drive).toThrow("Google API client not initialized");
  });

  it("should throw when accessing oauth2 before initialization", () => {
    const client = new GoogleApiClient();
    expect(() => client.oauth2).toThrow("Google API client not initialized");
  });

  it("should handle initialization failure", async () => {
    const { google } = await import("googleapis");
    
    // Make OAuth2 constructor throw
    (google.auth.OAuth2 as any).mockImplementationOnce(() => {
      throw new Error("OAuth2 initialization failed");
    });

    const client = new GoogleApiClient({
      credentials: {
        clientId: "test-client-id",
        clientSecret: "test-client-secret",
      },
    });

    await expect(client.initialize()).rejects.toThrow();
  });
});
