# Claude Code Rules (ServalSheets)

**Auto-read file for Claude Code** - These rules are enforced by CI.

## Live State & Session Context

Live project state (auto-generated, zero maintenance): @.serval/state.md
Session notes (what's in progress, decisions, next steps): @.serval/session-notes.md

> **How this works:** `.serval/state.md` is regenerated by a SessionStart hook every session.
> `.serval/session-notes.md` is updated by each session as its last act.
> Together they provide 100% context continuity across sessions.

## Project Overview

ServalSheets is a production-grade MCP (Model Context Protocol) server for Google Sheets with 22 tools and 315 actions. It provides AI-powered spreadsheet operations with safety rails, transactions, batch operations, and enterprise features.

**Version:** 1.7.0 | **Protocol:** MCP 2025-11-25 | **Runtime:** Node.js + TypeScript (strict)

## Complete Architecture Map

### Entrypoints (3 transport modes)

| File                           | Lines | Transport           | Usage                         |
| ------------------------------ | ----- | ------------------- | ----------------------------- |
| `src/cli.ts` → `src/server.ts` | 1400  | STDIO               | Claude Desktop, CLI (default) |
| `src/http-server.ts`           | 2809  | HTTP/SSE/Streamable | Cloud deployment, connectors  |
| `src/remote-server.ts`         | 11    | HTTP + OAuth 2.1    | Multi-tenant remote access    |

### Core Pipeline (request flow)

```
MCP Request → src/server.ts:handleToolCall()
  → src/mcp/registration/tool-handlers.ts:createToolCallHandler()
    → normalizeToolArgs() (legacy envelope handling)
    → Zod schema validation (src/schemas/*.ts)
    → src/handlers/*.ts:executeAction() (business logic)
      → src/services/google-api.ts (auto-retry + circuit breaker via Proxy)
        → Google Sheets/Drive/BigQuery API
    → buildToolResponse() (output schema validation + MCP formatting)
  → CallToolResult to client
```

### Request Flow Checkpoints (Execution Tracing)

**When modifying handlers or debugging, verify these 4 layers:**

#### Layer 1: Input Validation (3 stages)

```
src/mcp/registration/tool-handlers.ts:81-118
├─ normalizeToolArgs() - Legacy envelope unwrapping
│  Converts { request: { action, ...params } } → { action, ...params }
├─ src/schemas/fast-validators.ts - Pre-Zod validation (0.1ms)
│  Fast fail on invalid spreadsheetId format, missing required fields
└─ Handler Zod schema - Full validation via parseWithCache()
   Strict schema validation with detailed error messages
```

**Why 3 stages?** Performance optimization - reject invalid requests in 0.1ms before expensive Zod parsing.

#### Layer 2: Handler Execution

```
src/handlers/{tool-name}.ts:executeAction()
├─ Extract discriminated union action
│  const { action, ...params } = unwrapRequest(request);
├─ Switch statement dispatches to action handler
│  switch (action) { case 'read_range': return this.handleReadRange(params); }
└─ Returns structured response (NOT MCP format yet)
   { response: { success: true, data: {...} } }
```

**Key pattern:** ALL 22 handlers follow this exact structure (verified in src/handlers/\*.ts).

#### Layer 3: Response Building

```
src/mcp/registration/tool-handlers.ts:500+
├─ buildToolResponse() - Converts to MCP CallToolResult format
│  Adds { content: [...], structuredContent: {...}, isError: false }
├─ Output validation (ADVISORY, not blocking)
│  Logs warnings if response doesn't match output schema
└─ Returns MCP-compliant response
   { content: [{ type: 'text', text: 'Success' }], ... }
```

**Critical:** Handlers NEVER call `buildToolResponse()` - only the tool layer does this.

#### Layer 4: Service Layer (Auto-instrumented)

```
src/services/google-api.ts
├─ wrapGoogleApi() - Proxy pattern wraps all Google API calls
│  Automatically applied to sheets, drive, bigquery clients
├─ Auto-retry (3x exponential backoff + jitter)
│  Retries on 429 (rate limit), 500, 502, 503, 504
├─ Circuit breaker per endpoint
│  Opens after 5 failures, half-opens after 30s
└─ HTTP/2 connection pooling + metrics
   Prometheus metrics for latency, errors, circuit breaker state
```

**Why automatic?** All handlers extend `BaseHandler` which provides instrumented `this.context.googleClient`.

#### Example Complete Trace

```
Client: sheets_data tool with action=read_range
  ↓
server.ts:428 → handleToolCall('sheets_data', args)
  ↓
tool-handlers.ts:85 → createToolCallHandler()
  ↓
tool-handlers.ts:102 → normalizeToolArgs(args)
  → Unwraps { request: { action: 'read_range', ... } }
  ↓
tool-handlers.ts:115 → parseWithCache(schema, normalizedArgs)
  → Zod validates input against sheets_data schema
  ↓
handlers/data.ts:34 → executeAction(validatedInput)
  ↓
handlers/data.ts:48 → switch (action) → handleReadRange(params)
  ↓
handlers/data.ts:156 → this.context.googleClient.sheets.spreadsheets.values.get(...)
  → wrapGoogleApi() intercepts call
  → Auto-retry logic + circuit breaker check
  → HTTP/2 request to Google Sheets API
  ↓
handlers/data.ts:170 → return { response: { success: true, data: values } }
  ↓
tool-handlers.ts:520 → buildToolResponse(result)
  → Converts to MCP format
  → Output validation (advisory)
  ↓
server.ts:435 → Returns CallToolResult to client
```

**Use this trace pattern when:**

- Debugging handler execution
- Adding new tools/actions
- Understanding where errors originate
- Optimizing performance bottlenecks

### Directory Structure

```
src/
├── cli.ts                    # CLI entry + auth setup wizard
├── server.ts                 # STDIO MCP server (1400 lines)
├── http-server.ts            # HTTP MCP server + middleware chain (2809 lines)
├── remote-server.ts          # OAuth wrapper over http-server (11 lines)
├── schemas/                  # Zod schemas (SOURCE OF TRUTH for actions)
│   ├── index.ts              # Re-exports + TOOL_COUNT/ACTION_COUNT constants
│   ├── annotations.ts        # Per-tool + per-action annotations (SEP-973)
│   ├── descriptions.ts       # LLM-optimized tool descriptions with decision guides
│   ├── fast-validators.ts    # Pre-Zod fast validation (0.1ms)
│   ├── auth.ts               # sheets_auth (4 actions)
│   ├── core.ts               # sheets_core (19 actions)
│   ├── data.ts               # sheets_data (18 actions)
│   ├── format.ts             # sheets_format (22 actions)
│   ├── dimensions.ts         # sheets_dimensions (28 actions)
│   ├── visualize.ts          # sheets_visualize (18 actions)
│   ├── collaborate.ts        # sheets_collaborate (35 actions)
│   ├── advanced.ts           # sheets_advanced (26 actions)
│   ├── transaction.ts        # sheets_transaction (6 actions)
│   ├── quality.ts            # sheets_quality (4 actions)
│   ├── history.ts            # sheets_history (7 actions)
│   ├── confirm.ts            # sheets_confirm (5 actions)
│   ├── analyze.ts            # sheets_analyze (16 actions)
│   ├── fix.ts                # sheets_fix (1 action)
│   ├── composite.ts          # sheets_composite (11 actions)
│   ├── session.ts            # sheets_session (26 actions)
│   ├── templates.ts          # sheets_templates (8 actions)
│   ├── bigquery.ts           # sheets_bigquery (14 actions)
│   ├── appsscript.ts         # sheets_appsscript (14 actions)
│   ├── webhook.ts            # sheets_webhook (6 actions)
│   └── dependencies.ts       # sheets_dependencies (7 actions)
├── handlers/                 # Business logic (1 per tool)
│   ├── base.ts               # BaseHandler (1497 lines - circuit breaker, instrumented API calls)
│   ├── helpers/              # Shared helpers (request-helpers, validation-helpers, column-helpers)
│   ├── auth.ts ... deps.ts   # 22 handler files (13 extend BaseHandler, 9 are standalone)
│   └── index.ts              # Handler factory + registry
├── mcp/                      # MCP protocol layer
│   ├── registration/
│   │   ├── tool-definitions.ts    # TOOL_DEFINITIONS array (22 entries with input/output schemas)
│   │   ├── tool-handlers.ts       # createToolCallHandler + buildToolResponse
│   │   ├── schema-helpers.ts      # Zod → JSON Schema conversion + caching
│   │   ├── tools-list-compat.ts   # tools/list response formatting
│   │   └── extraction-helpers.ts  # Action/spreadsheetId/error extraction
│   ├── completions.ts        # TOOL_ACTIONS map for autocomplete
│   └── features-2025-11-25.ts # Server instructions + execution config
├── services/                 # Infrastructure services
│   ├── google-api.ts         # GoogleApiClient (auto-retry, circuit breaker, HTTP/2)
│   ├── transaction-manager.ts # Atomic batch operations
│   ├── user-rate-limiter.ts  # Per-user rate limiting (Redis)
│   ├── request-merger.ts     # Overlapping read merging
│   ├── circuit-breaker-registry.ts # Global circuit breaker tracking
│   ├── history-service.ts    # Operation history (undo/redo)
│   ├── session-context.ts    # Per-conversation state
│   ├── token-manager.ts      # Proactive OAuth token refresh
│   └── webhook-*.ts          # Webhook manager/queue/worker
├── middleware/               # HTTP middleware
│   └── redaction.ts          # Auto-redact tokens/keys from responses
├── utils/                    # Shared utilities
│   ├── retry.ts              # executeWithRetry (exponential backoff + jitter)
│   ├── circuit-breaker.ts    # CircuitBreaker (CLOSED/OPEN/HALF_OPEN)
│   ├── request-deduplication.ts # In-flight + result cache dedup
│   ├── action-intelligence.ts # Per-action hints, batch suggestions
│   ├── schema-compat.ts      # Zod v4 → JSON Schema conversion
│   ├── error-factory.ts      # Structured error creation (40+ codes)
│   ├── enhanced-errors.ts    # Google API error → ServalSheets error mapping
│   ├── request-context.ts    # Per-request context (tracing, deadline)
│   ├── response-compactor.ts # Context window pressure reduction
│   └── logger.ts             # Structured logging (Winston)
├── knowledge/                # AI knowledge base (40 files)
│   ├── api/                  # Google API guides
│   │   ├── error-handling.md           # Error recovery patterns (994 lines)
│   │   └── limits/quotas.json          # Quota details + optimization (622 lines)
│   ├── formulas/             # Spreadsheet formula reference
│   ├── masterclass/          # Deep-dive performance/security guides
│   ├── templates/            # Industry CRM/inventory/project templates
│   └── workflow-intelligence.json # Decision trees + anti-patterns (629 lines)
├── observability/            # Metrics + tracing
│   └── metrics.ts            # Prometheus metrics (prom-client)
├── resources/                # MCP resources
│   ├── schemas.ts            # schema://tools/{name} resource provider
│   └── temporary-storage.ts  # Large response overflow storage
├── config/                   # Configuration
│   ├── env.ts                # Environment variable parsing + defaults (60+ env vars)
│   └── oauth-scopes.ts       # Google OAuth scope management
├── analysis/                 # AI analysis helpers (14 files, used by analyze handler)
├── startup/                  # Lifecycle/preflight/restart management (5 files)
├── security/                 # Webhook signatures, resource indicators, incremental scope (4 files)
├── storage/                  # Session manager + session store (3 files)
├── graphql/                  # GraphQL API (4 files, P3-1 feature)
├── admin/                    # Admin dashboard routes (2 files)
├── di/                       # Dependency injection container (1 file)
├── adapters/                 # Backend adapters for serval-core (google-sheets-backend.ts)
└── core/                     # Core types + errors
    └── errors.ts             # Base error classes
```

### Test Structure

```
tests/
├── contracts/     # 667 schema guarantee tests (MUST always pass)
├── security/      # 34 security tests (redaction, input sanitization, resource indicators)
├── handlers/      # Handler unit tests (per-tool)
├── schemas/       # Schema validation tests
├── utils/         # Utility function tests
├── services/      # Service integration tests
├── unit/          # Pure unit tests
├── compliance/    # MCP protocol compliance tests
├── property/      # Property-based (fuzz) tests
├── safety/        # Safety rail tests
├── benchmarks/    # Performance benchmarks
├── live-api/      # Real Google API tests (requires TEST_REAL_API=true)
└── snapshots/     # Response snapshot tests
```

### Key Configuration Files

| File                      | Purpose                                                       |
| ------------------------- | ------------------------------------------------------------- |
| `server.json`             | MCP registry metadata + AI instructions (sent to all clients) |
| `package.json`            | Dependencies, scripts, version                                |
| `tsconfig.json`           | TypeScript strict mode config                                 |
| `tsconfig.build.json`     | Build-specific TS config                                      |
| `eslint.config.js`        | ESLint flat config                                            |
| `vitest.config.ts`        | Test runner config                                            |
| `.dependency-cruiser.cjs` | Architecture rule enforcement                                 |

### Reliability Infrastructure (automatic, opt-out)

| Feature                              | File                                                       | Default             |
| ------------------------------------ | ---------------------------------------------------------- | ------------------- |
| Auto-retry (3x, exponential backoff) | `src/services/google-api.ts` via `wrapGoogleApi()`         | ON                  |
| Circuit breaker (per-client)         | `src/services/google-api.ts` via `wrapGoogleApi()`         | ON                  |
| Request deduplication                | `src/utils/request-deduplication.ts`                       | ON                  |
| Read merging (overlapping ranges)    | `src/services/request-merger.ts`                           | ON                  |
| Output schema validation             | `src/mcp/registration/tool-handlers.ts`                    | ON (advisory)       |
| Response redaction (tokens/keys)     | `src/middleware/redaction.ts`                              | ON in production    |
| Per-user rate limiting               | `src/http-server.ts` + `src/services/user-rate-limiter.ts` | ON (requires Redis) |
| HTTP/2 connection pooling            | `src/services/google-api.ts`                               | ON                  |
| Proactive token refresh              | `src/services/token-manager.ts`                            | ON                  |

## NO Documentation File Creation

**NEVER create these files:**

- Session logs, audit reports, analysis docs
- `*_REPORT.md`, `*_ANALYSIS.md`, `*_LOG.md`, `*_SUMMARY.md`
- Any markdown file documenting what you did
- Status updates, progress reports, implementation plans

**Instead:**

- Report findings directly in chat
- If user needs a file, they'll ask explicitly
- Code changes only - no meta-documentation

## Non-negotiable Workflow

1. **Verify before claiming:**
   - Every factual claim must include: `file:line` OR `command → output snippet`
   - Run `npm run verify` before every commit

2. **Trace execution paths:**
   - Prove reachability from an entrypoint:
     - STDIO: `src/cli.ts` → `src/server.ts` → handler
     - HTTP: `src/http-server.ts` → handler
     - Remote: `src/remote-server.ts` → handler

3. **No "fixes" without failing proof:**
   - Either reproduce with a script, or add a test that fails first
   - No exceptions for "obvious" fixes

4. **Minimal change policy:**
   - Prefer the smallest patch (≤3 src/ files unless tests require more)
   - Do NOT refactor while debugging
   - Schema changes may touch generated files (acceptable)

5. **No silent fallbacks:**
   - Never `return {}` or `return undefined` without logging
   - Use structured errors with `ErrorCode` enum
   - Run `npm run check:silent-fallbacks` to verify

6. **Dead code claims require coverage proof:**
   - NEVER claim code is "dead" or "unreachable" without running `npm run validate:dead-code <file> <start-line> <end-line>`
   - If tests pass AND coverage > 0%, code is NOT dead
   - Dead code claims must show 0% coverage proof
   - Use `.github/AUDIT_TEMPLATE.md` for proper audit format

7. **Schema-handler alignment validation:**
   - Run `npm run validate:alignment` to check all 22 tools
   - Understand distinction: Action-level cases vs Parameter-level cases
   - Action-level: `switch (request.action)` → Must match schema discriminated union
   - Parameter-level: `switch (input.preset)` → Implementation detail, NOT schema actions
   - Contract test enforces alignment: `tests/contracts/schema-handler-alignment.test.ts`
   - **Acceptable deviations:** Documented in `src/schemas/handler-deviations.ts`
     - Aliases/shortcuts are allowed if explicitly documented
     - Example: `sheets_core` has 6 documented aliases (copy_to → copy_sheet_to, hide_sheet → update_sheet, etc.)
     - UNDOCUMENTED deviations cause CI failure
     - Add new deviations to `ACCEPTABLE_DEVIATIONS` array with clear justification

8. **Audit document validation:**
   - All audit documents MUST pass `npm run validate:audit`
   - Include command outputs proving claims
   - Show test results and coverage data
   - Follow `.github/AUDIT_TEMPLATE.md` format

## Required Verification Pipeline

```bash
# Full verification (MUST pass before commit)
npm run verify

# Individual checks
npm run typecheck           # TypeScript strict mode
npm run lint                # ESLint
npm run test                # 1700+ tests
npm run check:drift         # Metadata sync
npm run check:placeholders  # No TODO/FIXME in src/
npm run check:debug-prints  # No console.log in handlers
npm run check:silent-fallbacks  # No silent {} returns
npm run validate:alignment  # Schema-handler alignment (NEW)
npm run validate:audit      # Audit document validation (NEW)

# Dead code verification
npm run validate:dead-code <file> <start> <end>  # Verify dead code claims

# Build verification
npm run verify:build        # Build + validate + smoke

# Full gate pipeline (G0-G5)
npm run gates               # Run all validation gates
```

## Fast Development Workflows

### Schema Changes (ONE command)

When modifying any schema file in `src/schemas/*.ts`, use this single command:

```bash
npm run schema:commit
```

This command automatically:

1. Regenerates metadata (`gen:metadata`)
2. Verifies no drift (`check:drift`)
3. Runs TypeScript checks (`typecheck`)
4. Runs fast tests (`test:fast`)
5. Stages all changed files for commit

**Impact:** Reduces 5 manual steps to 1 command, saves ~2 minutes per schema change.

### Quick Verification Commands (< 10 seconds)

Before claiming "verified", run these fast checks:

```bash
npm run check:drift        # Verify metadata sync (2-3 seconds)
npm run test:fast          # Run unit + contract tests (5-8 seconds)
npm run typecheck          # Check TypeScript errors (10-15 seconds)
```

### Verification Requirements

**ALWAYS include proof with claims:**

- File references: `src/server.ts:42` (specific line)
- Command output: Show actual output snippet
- NEVER claim "verified" without running at least `npm run check:drift`

**Example of proper verification:**

```bash
$ npm run check:drift
✓ No metadata drift detected

$ wc -l src/server.ts
1400 src/server.ts
```

## Common Gotchas & Solutions

**⚠️ These are the top causes of CI failures and development friction:**

### 1. Metadata Drift After Schema Changes

**Symptom:** CI fails with "metadata drift detected"

**Cause:** Modified `src/schemas/*.ts` without regenerating metadata files

**Solution:** Run `npm run schema:commit` after ANY schema change

**Prevention:** This is the #1 cause of CI failures (15+ occurrences in last 2 months)

**Why it happens:** Metadata is auto-generated in 5 files:

- `src/schemas/index.ts` - TOOL_COUNT/ACTION_COUNT constants
- `src/schemas/annotations.ts` - Per-tool action counts
- `src/mcp/completions.ts` - TOOL_ACTIONS autocomplete map
- `server.json` - Full MCP metadata
- `package.json` - Description with counts

### 2. Response Builder Anti-Pattern

**Symptom:** MCP SDK logs "invalid response structure" warnings

**Cause:** Handler returns raw object instead of using `buildToolResponse()`

**Solution:**

```typescript
// ❌ Wrong - manual construction
return { content: [{ type: 'text', text: 'result' }] };

// ✅ Correct - use response builder
return buildToolResponse({ response: { success: true, data } });
```

**Why it matters:** Response building happens in `src/mcp/registration/tool-handlers.ts`, NOT in handlers. Handlers return structured data, tool layer converts to MCP format.

### 3. Hardcoded Counts in Documentation

**Symptom:** README shows outdated counts but CI says "22 tools, 315 actions"

**Cause:** Using hardcoded numbers instead of source file references

**Solution:** Always reference the source:

- Tool count: See `src/schemas/index.ts:63` → `TOOL_COUNT`
- Action count: See `src/schemas/index.ts:63` → `ACTION_COUNT`

**Example:** "Currently 22 tools with 315 actions (see src/schemas/index.ts:63)"

**Prevention:** CI checks 42+ documentation files for hardcoded count mismatches

### 4. Line Count Claims Without Verification

**Symptom:** Documentation says "~900 lines" but file is actually 1400 lines

**Cause:** Using estimates ("~", "approximately") instead of running `wc -l`

**Solution:** Always include actual command output:

```bash
$ wc -l src/server.ts
1400 src/server.ts
```

**Never use:** "approximately", "roughly", "around", "~" for line counts

### 5. Silent Fallback Pattern

**Symptom:** Handler returns empty object `{}` without throwing error

**Cause:** Missing error handling, guard clauses without logging, or early returns

**Solution:** Use structured errors with `ErrorCode` enum:

```typescript
// ❌ Wrong - silent failure
if (!sheet) return {};

// ✅ Correct - explicit error
if (!sheet) {
  throw new SheetNotFoundError('Sheet not found', {
    spreadsheetId,
    sheetName,
  });
}
```

**Detection:** Run `npm run check:silent-fallbacks` to find these patterns

### 6. Legacy Envelope Wrapping Confusion

**Symptom:** Tests fail with "action is required" but action is clearly provided

**Cause:** Legacy compatibility layer expects `{ request: { action, ...params } }` format

**Location:** `src/mcp/registration/tool-handlers.ts:81-118` - `normalizeToolArgs()`

**Solution:** Most test inputs need wrapping:

```typescript
// ❌ Wrong - direct input
const input = { action: 'read_range', spreadsheetId: '...' };

// ✅ Correct - wrapped input (for tests)
const input = { request: { action: 'read_range', spreadsheetId: '...' } };
```

**Note:** Production MCP requests are automatically wrapped, only affects test code.

## Key Files to Focus On

- `src/server.ts` - MCP server entrypoint (1400 lines)
- `src/mcp/registration/*` - Tool + schema registration
- `src/handlers/*` - Tool handlers (22 tools)
- `src/schemas/*` - Zod schemas (validation source of truth)
- `src/utils/schema-compat.ts` - Schema transformation layer
- `tests/contracts/*` - Contract tests (schema guarantees)

## ServalSheets-Specific Patterns

### Layered Validation (Performance Critical)

```typescript
// 1. Fast validators first (0.1ms)
fastValidateSpreadsheet(input);
// 2. Full Zod validation (1-2ms)
const validated = Schema.parse(input);
// 3. Shape checking in handler
if (!result.response) throw new ResponseValidationError(...);
```

### Response Builder (MCP Compliance)

```typescript
// ✅ Always use response builder
return buildToolResponse({ response: { success: true, data } });

// ❌ Never construct manually
return { content: [...], structuredContent: data };
```

### Structured Errors (40+ error codes)

```typescript
// ✅ Typed error
throw new SheetNotFoundError('Sheet not found', { spreadsheetId, sheetName });

// ❌ Generic error
throw new Error('Sheet not found');
```

## Coding Style Guide

### Import Ordering (consistent across all handler files)

```typescript
// 1. Google APIs / external types
import type { sheets_v4, drive_v3 } from 'googleapis';
// 2. Internal domain (base handler)
import { BaseHandler, unwrapRequest } from './base.js';
// 3. Core types
import type { Intent } from '../core/intent.js';
// 4. Config
import { getEnv } from '../config/env.js';
// 5. Services
import { getBackgroundAnalyzer } from '../services/...js';
// 6. Utils
import { buildA1Notation, parseA1Notation } from '../utils/...js';
// 7. Schemas / types
import type { SheetsDataInput } from '../schemas/data.js';
// 8. MCP layer
import { confirmDestructiveAction } from '../mcp/...js';
```

### Naming Conventions

- **Handler action methods:** `private async handle{ActionName}(input: ActionInput): Promise<Response>`
- **Test mock factories:** `createMock{Type}()` — always returns typed object with `vi.fn()` mocks
- **Converters:** `{source}To{target}()` (e.g., `hexToRgb`, `columnLetterToIndex`)
- **Validators:** `validate{Thing}()` (e.g., `validateScopes`, `validateHyperlinkUrl`)
- **Input types:** `{Tool}{Action}Input` (e.g., `DataReadInput`, `CoreCreateInput`)
- **Output types:** `{Tool}Output` (e.g., `SheetsDataOutput`)
- **Handler files:** `{tool}.ts` (matches schema file name)
- **Test files:** `{tool}.test.ts`, `{tool}-{bugfix}.test.ts`, `{tool}.{feature}.test.ts`

### Comment Style

- JSDoc header on every handler file with tool name, action count, and action categories
- Inline comments explain **why**, not **what**
- Fix references: `// Fix 1.4: Format operation batching queue`
- Feature flags: `// Feature flag check`

## Handler Architecture

### BaseHandler vs Standalone (important distinction)

**13 handlers extend BaseHandler** (have circuit breakers, `this.success()`, instrumented API):
advanced, analyze, appsscript, bigquery, collaborate, composite, core, data, dimensions, fix, format, templates, visualize

**9 handlers are standalone** (NO circuit breakers, different response patterns):
auth, confirm, dependencies, federation, history, quality, session, transaction, webhooks

### Full Handler Lifecycle

```typescript
// 1. Public entry point is handle() — NOT executeAction()
async handle(input: TInput): Promise<TOutput> {
  const req = unwrapRequest<TInput['request']>(input);
  this.setVerbosity(req.verbosity ?? 'standard');
  return this.executeAction(req);
}

// 2. Private dispatcher
private async executeAction(request: DataRequest): Promise<DataResponse> {
  switch (request.action) {
    case 'read': return this.handleRead(request);
    // ...
    default: throw new ValidationError(`Unknown action: ${request.action}`);
  }
}

// 3. Per-action handlers (private, always async, always typed)
private async handleRead(input: DataReadInput): Promise<DataResponse> {
  try {
    const req = this.inferRequestParameters(input);
    // ... business logic ...
    return this.success('read', { values, range }, mutation);
  } catch (error) {
    return { response: this.mapError(error) };
  }
}
```

### Handler Response Patterns

```typescript
// BaseHandler success (13 handlers):
return this.success('action_name', data, optionalMutation);

// Standalone handler success (9 handlers):
return { response: { success: true, action: 'action_name', ...data } };

// Error path (both):
return { response: this.mapError(error) };
```

## Adding a New Action (Recipe)

**Step 1: Schema** (`src/schemas/{tool}.ts`)
```typescript
const NewActionSchema = CommonFieldsSchema.extend({
  action: z.literal('new_action').describe('Description here'),
  param1: z.string().describe('...'),
});

// Add to discriminated union:
request: z.discriminatedUnion('action', [
  ...existingSchemas,
  NewActionSchema,
])
```

**Step 2: Handler** (`src/handlers/{tool}.ts`)
```typescript
// Add case in executeAction:
case 'new_action':
  return this.handleNewAction(request as DataRequest & { action: 'new_action' });

// Add private method:
private async handleNewAction(input: NewActionInput): Promise<Response> {
  // implementation
}
```

**Step 3: Test** (`tests/handlers/{tool}.test.ts`)
- Add test under new describe block
- Mock API responses with `createMock{Type}()`
- Test success and error paths

**Step 4: Metadata** (ONE command)
```bash
npm run schema:commit
```

## Useful npm Scripts (Beyond verify)

The project has 259 scripts. Key ones not in the main verification pipeline:

```bash
# Performance Profiling
npm run profile:cpu        # CPU profiling
npm run profile:memory     # Memory profiling
npm run profile:flame      # Flame graph generation

# Analysis
npm run analyze:*          # Various analysis scripts (6 variants)

# Monitoring
npm run monitor:*          # Live monitoring tools (5 variants)

# Safe verification (skips lint for low-memory environments)
npm run verify:safe        # Use when lint OOMs due to memory constraints

# Schema workflow (after any schema change)
npm run schema:commit      # Regenerate + verify + test + stage
```

## Audit Mode Prompt

When starting work, operate as an auditor:

1. Show the exact execution path (entrypoint → callsite)
2. Run `npm run verify` and report failures (or `verify:safe` if lint OOMs)
3. Reproduce the bug with a failing test
4. Only then propose a minimal patch (≤3 files)
5. No refactors in the same PR

## Source of Truth Reference

**ALWAYS verify these values from their authoritative sources:**

| Metric               | Source File            | Current Value  |
| -------------------- | ---------------------- | -------------- |
| **ACTION_COUNT**     | `src/schemas/index.ts` | 315 actions    |
| **TOOL_COUNT**       | `src/schemas/index.ts` | 22 tools       |
| **Protocol Version** | `src/version.ts:14`    | MCP 2025-11-25 |
| **Zod Version**      | `package.json`         | 4.3.6          |
| **SDK Version**      | `package.json`         | 1.26.0         |

**How to verify:**

```bash
# Get current action/tool counts
npm run check:drift

# Get actual line counts
wc -l src/server.ts src/handlers/base.ts

# Verify protocol version
grep "MCP_PROTOCOL_VERSION" src/version.ts
```

**⚠️ NEVER hardcode these values in documentation** - always reference the source file with `file:line`.

---

## Tool Usage Decision Tree (Claude Code)

**Use this guide to choose the right tool for file operations:**

### START: What do you need to do?

#### ✅ Know the exact file path?

→ **Use `Read` tool**

- Fastest option when path is known
- Supports line offsets for large files
- Can read images, PDFs, Jupyter notebooks
- Example: `Read("src/server.ts")`

#### ✅ Need to find files by pattern?

→ **Use `Glob` tool** (NOT `find` or `ls`)

- Pattern-based file discovery
- Much faster than Bash find/ls
- Examples:
  - Find all test files: `**/*.test.ts`
  - Find handler files: `src/handlers/*.ts`
  - Find schema files: `src/schemas/*.ts`

#### ✅ Need to search file contents?

→ **Use `Grep` tool** (NOT bash `grep` or `rg`)

- Regex pattern search across files
- Supports context lines (-A, -B, -C)
- Output modes:
  - `content` - Show matching lines
  - `files_with_matches` - List files only
  - `count` - Count matches per file
- Examples:
  - Find function usage: `Grep("handleReadRange", output_mode="content")`
  - Find TODO comments: `Grep("TODO|FIXME", output_mode="files_with_matches")`
  - Count action occurrences: `Grep("action:", output_mode="count")`
- Add `-i` flag for case-insensitive search

#### ✅ Need to run npm scripts or git commands?

→ **Use `Bash` tool**

- Git operations: `git status`, `git log`, `git diff`
- npm scripts: `npm run verify`, `npm test`, `npm run check:drift`
- Line counts: `wc -l file.ts`
- Build commands: `npm run build`

#### ❌ NEVER use Bash for:

- **File reading** (cat, head, tail) → Use `Read` tool
- **Text search** (grep, rg, ag) → Use `Grep` tool
- **File finding** (find, ls) → Use `Glob` tool
- **File manipulation** (sed, awk) → Use `Edit` tool
- **File writing** (echo >, cat <<EOF) → Use `Write` tool

### Performance Guide

| Operation       | Slow ❌                            | Fast ✅                        |
| --------------- | ---------------------------------- | ------------------------------ |
| Read known file | `Bash("cat src/server.ts")`        | `Read("src/server.ts")`        |
| Find test files | `Bash("find . -name '*.test.ts'")` | `Glob("**/*.test.ts")`         |
| Search for text | `Bash("grep -r 'pattern' src/")`   | `Grep("pattern", path="src/")` |
| Count lines     | `Bash("cat file \| wc -l")`        | `Read("file")` then count      |

### Parallel Operations

When operations are independent, call multiple tools in one message:

```
✅ Correct - Parallel reads (3 simultaneous calls)
Read("src/server.ts")
Read("src/handlers/data.ts")
Read("src/schemas/data.ts")

❌ Wrong - Sequential reads (3x slower)
Read("src/server.ts") → wait → Read("src/handlers/data.ts") → wait → ...
```

**Rule:** If operations don't depend on each other, make all calls in a single message.

### MCP-Specific Patterns

**When adding new tools to ServalSheets:**

1. **Define schema:** Use `Glob("src/schemas/*.ts")` to see existing patterns
2. **Create handler:** Use `Read("src/handlers/base.ts")` to see base structure
3. **Register tool:** Use `Grep("TOOL_DEFINITIONS", path="src/mcp/registration/")` to find registry
4. **Run metadata:** `Bash("npm run schema:commit")` to regenerate + verify + test

**When debugging handler execution:**

1. **Trace flow:** Use execution path checkpoints (see Layer 1-4 above)
2. **Find handler:** `Glob("src/handlers/**/your-tool.ts")`
3. **Read handler:** `Read("src/handlers/your-tool.ts")`
4. **Check tests:** `Glob("tests/handlers/**/your-tool.test.ts")`
5. **Run tests:** `Bash("npm test tests/handlers/your-tool.test.ts")`

---

## Metadata Generation (Automated)

The `scripts/generate-metadata.ts` script automatically updates these files:

**Input (Source of Truth):**

- `src/schemas/*.ts` - Individual tool schemas with `z.enum([...])` actions

**Output (Generated - DO NOT edit manually):**

- `package.json` - Description with tool/action counts
- `src/schemas/index.ts` - `TOOL_COUNT` and `ACTION_COUNT` constants
- `src/schemas/annotations.ts` - `ACTION_COUNTS` per-tool breakdown
- `src/mcp/completions.ts` - `TOOL_ACTIONS` for autocompletion
- `server.json` - Full MCP server metadata

**When to run:**

```bash
# After modifying any schema file
npm run gen:metadata

# Verify no drift
npm run check:drift
```

**The script supports:**

- ✅ `z.enum([...])` action arrays (current pattern)
- ✅ `z.literal('action')` single actions
- ✅ Special case tools (fix, validation, impact, analyze, confirm)

---

## Known Issues & Current Status

**Build Status:** ✅ **PASSING** (as of 2026-02-21)

> **Note:** For live status, see the auto-generated `.serval/state.md` (imported above).
> The SessionStart hook regenerates it every session from source code.

**Pre-existing issues:**
- ESLint may OOM in low-memory environments (requires ~4GB heap for full project linting)
- Silent fallback check reports 47 false positives (legitimate `string | undefined` returns)

**Resolved (Session 12):**
- ~~`npm run check:drift` hangs~~ — Fixed: removed `npx prettier` calls from generate-metadata.ts, switched to `node --import tsx`
- ~~ESLint AJV crash~~ — Fixed: `@eslint/eslintrc` now has ajv@6 in nested node_modules (package.json override added)

**Check current status:**

```bash
npm run verify 2>&1 | tee verify-output.txt
npm run audit:full    # Full audit suite
```

---

## Deleted Files (Do Not Reference)

**These files have been removed and should NOT be referenced:**

| File                                  | Deleted    | Reason                     | Replacement           |
| ------------------------------------- | ---------- | -------------------------- | --------------------- |
| `src/mcp/sdk-compat.ts`               | 2026-01-11 | Schema flattening complete | Native SDK conversion |
| `tests/contracts/sdk-compat.test.ts`  | 2026-01-11 | Test for deleted file      | N/A                   |
| `src/server-v2.ts`                    | 2026-01-14 | V2 architecture abandoned  | N/A                   |
| `src/server-compat.ts`                | 2026-01-14 | V2 architecture abandoned  | N/A                   |
| `src/migration-v1-to-v2.ts`           | 2026-01-14 | V2 architecture abandoned  | N/A                   |
| `src/schemas-v2/`                     | 2026-01-14 | V2 architecture abandoned  | N/A                   |
| `src/handlers-v2/`                    | 2026-01-14 | V2 architecture abandoned  | N/A                   |
| `src/services/snapshot-service.ts`    | 2026-01-14 | Unused V2 service          | N/A                   |
| `src/__tests__/handlers-v2.test.ts`   | 2026-01-14 | V2 test file               | N/A                   |
| `docs/archive/2026-01/`               | 2026-01-14 | Old debug logs             | N/A                   |
| `docs/archive/2026-01-debug-session/` | 2026-01-14 | Old debug logs             | N/A                   |

**Git evidence:** V2 files were never committed (untracked). Planning docs archived in `docs/archive/abandoned-v2/`

---

## sheets_session Tool

**Status:** ✅ Fully Implemented and Integrated

The `sheets_session` tool provides conversational context management.

**All locations now synchronized:**

- ✅ `src/schemas/session.ts` - Schema definition
- ✅ `src/handlers/session.ts` - Handler implementation
- ✅ `src/mcp/registration/tool-definitions.ts` - Registered
- ✅ `src/schemas/index.ts` - In `TOOL_REGISTRY` export
- ✅ `src/schemas/fast-validators.ts` - Comment updated to "ALL 22 tools"
- ✅ `tests/contracts/schema-contracts.test.ts` - TOOL_SCHEMAS array has 22 entries
- ✅ `src/mcp/completions.ts` - Comment updated to "315 actions across 22 tools"
- ✅ Tool is functional and working

**Note:** After Wave 5 consolidation and Tier 7 additions, we have 22 total tools with 315 actions (as of 2026-02-18)

---

## Server Consolidation (2026-01-14)

**Status:** ✅ Completed

The HTTP and OAuth servers have been consolidated into a single implementation.

**Current Architecture:**

- `src/server.ts` - STDIO transport (MCP over stdin/stdout)
- `src/http-server.ts` - HTTP/SSE transport with optional OAuth support
- `src/remote-server.ts` - Thin compatibility wrapper (calls http-server with OAuth enabled)

**Usage:**

```typescript
// Standard HTTP mode (token via Authorization header)
createHttpServer({ port: 3000 });

// OAuth mode (full OAuth 2.1 provider)
createHttpServer({
  port: 3000,
  enableOAuth: true,
  oauthConfig: {
    issuer: '...',
    clientId: '...',
    clientSecret: '...',
    jwtSecret: '...',
    stateSecret: '...',
    allowedRedirectUris: ['...'],
    googleClientId: '...',
    googleClientSecret: '...',
    accessTokenTtl: 3600,
    refreshTokenTtl: 604800,
  },
});

// Backward compatibility
startRemoteServer({ port: 3000 }); // Uses OAuth mode
```

**Code Reduction:** ~540 LOC of duplicated code eliminated

---

## Safe Rollback Strategy

When you need to undo changes during Phase implementation:

### Recommended: Phase-Specific Branches

```bash
# Create phase branch before starting
git checkout -b phase-0-foundation
git commit -m "checkpoint: Phase 0 start" --allow-empty

# Work on phase...

# If you need to rollback specific files
git restore --source=HEAD~3 -- src/handlers/data.ts

# If you need to abandon entire phase
git checkout main
git branch -D phase-0-foundation
```

### Per-File Rollback (Safe)

```bash
# Restore specific file from 3 commits ago
git restore --source=HEAD~3 -- <file>

# Restore file from specific commit
git restore --source=<commit-hash> -- <file>

# See file history first
git log --oneline -- <file>
```

### ❌ NEVER Use These (Destructive)

```bash
❌ git checkout -- .           # Discards all uncommitted work
❌ git reset --hard HEAD       # Destroys commits + work
❌ git clean -fd               # Deletes untracked files permanently
```

**Why:** These commands can destroy uncommitted work across the entire workspace, potentially losing hours of progress from yourself or collaborators.

**Rule:** Always use targeted `git restore --source=<commit> -- <file>` or phase branches instead of workspace-wide destructive operations.

---

## Full Documentation

See `docs/development/CLAUDE_CODE_RULES.md` for complete rules with examples.
See `docs/development/PROJECT_STATUS.md` for detailed current build status.
See `docs/development/SOURCE_OF_TRUTH.md` for complete reference guide.
